我们已经知道怎么让指令有自己的模板，这让它们更像一个独立的“组件”。我们也看到了怎么通过传递参数来自定义这些组件的行为，这里的参数包括作用域属性、独立作用域和 HTML 属性。

有时传递整个 HTML 结构给指令会更有用。一个典型的例子就是“标签页”组件，它会把自己渲染成一个标签页的集合，但允许组件使用者自定义标签页的实际内容。

可以想到，有人会认为像这样的功能已经在当前的指令系统实现了：举例来说，有人说我们可以把标签页的 HTML 内容塞到独立作用域的属性。或者可以使用基于手动的 DOM 操作的自定义方法。但这些都不是像“标签页”这种需求的最佳解决方案。这是因为在 Angular 里，我们不仅要关心 DOM 结构，还要关心用于数据分发的作用域继承。如果我们在 DOM 中使用了指令，我们会希望那些指令总能链接到合适的作用域上。

这就是`transclusion`(嵌入包含)的由来：transclusion 允许我们传递一段 DOM 结构给指令，并让指令决定在指令内部的哪里和如何进行使用。不仅这样，transclusion 还设置了一个作用于结构，这让同类型的 DOM 更容易进行移动：即使我们传入的 DOM 会被另一个指令模板使用，但它的作用域依然是我们之前定义它的地方（？）：在指令模板之外。

> `transclusion`这个词语有一点深奥，也因此经常受到质疑。但这个词语并不是 Angular 发明出来的，它在计算机科学领域确实有一段历史，本身还是很有趣的。如果你想象是把内含物（inclusion）从一个地方通过模板转移（trans）到另一个地方去。

除了替应用开发者管理作用域，transclusion 也可以去做被嵌入包含了的 DOM 元素的克隆。这让同一个 DOM 元素用不同的作用域内容进行多次链接成为了可能。举个例子，对集合里的每一个元素我们都可以嵌入包含一些 DOM 片段，这有点像是`ngRepeat`指令的作用。

有时我们希望能进行克隆，但又不想把东西从一处迁到另一处，transclusion 的克隆就能派上用场。为此，Angular 提供了`transclude: 'element'`配置项，这能够让我们可以使用 transclusion 的克隆和多次链接特性，而无需使用真正的 transclusion 功能。这也是实现`ng-repeat`等一些 Angular 核心指令的基础。

这就是我们要在本章中介绍的所有特性。transclusion 的实现代码会合并到`compile.js`里面的编译和链接过程中。本章中还会复习到很多有关这个文件的知识点。我们会从能想到的最简单的 transclusion 功能开始讲起：将一段 DOM 从一个模板转移到另一个模板。

> 下载[本章初始代码](https://github.com/teropa/build-your-own-angularjs/releases/tag/chapter20-directive-templates)