早些时候的 AngularJS 框架中，构成 Angular 应用的最常见的基本组件是控制器和模板，这两个组件分别通过`ng-controller`和`ng-include`指令生成。当我们需要插入一个新模板，就需要用到`ng-include`指令。当你需要需要加入业务逻辑，我们就需要在模板中加入`ng-controller`指令。

这种用法虽然很容易上手，但实际上会经常带来问题。因为`ng-controller`和`ng-include`都是使用继承作用域的指令，如果在整个应用中都使用这种指令来进行注册，则会形成一个庞大的 scope 原型继承链，里面的所有数据都是从父到子这样进行分享的。考虑到模块化的要求，这种全局化的数据分享并不是一个好主意。另外，这样也经常会引发一些难以跟踪的问题，因为应用的很多模块都进行了分享，并可能会改变全局的状态。

另外，由于`ng-controller`和`ng-include`是不同的两个指令，我们经常会无法在代码结构中展示出控制器和模板之间的直接关联。一个模板会使用多个控制器，而一个控制器也可能管理多个内嵌的模板。这会让代码变得难以跟踪维护，我们无法轻易地分辨出这个模板是跟一个给定的控制器绑定在一起的，相反亦然。

因此，很多人（实际上包括你们）都会逐渐转向另一个代码组织方式。这种方式不需要用到`ng-controller`和`ng-include`，而会采用自定义指令，这个指令包含以下特性：

- 每个指令都会有模板和控制器，这能形成一个紧密的配对关系。
- 数据输入和输出都使用独立作用域进行清晰的定义。
- 使用元素选择器（`restrict: 'E'`），明确表示表明这个指令会独占一个元素，而不用元素上的属性进行“装饰”。

这种模板被称为_组件模式_，因为它把所有用于呈现一个 UI 组件的东西都进行了组合、打包。

（AngularJS 推出这种模式的）同一时间，React 已经涉足这个领域，并在众多前段框架中，率先提出了[strictly component-based approach](https://reactjs.org/docs/thinking-in-react.html)用于构建 UI 代码。在 React 中，一切都建立在组件的基础上，所有视图的结果、样式和逻辑都使用组件进行打包。React 的设计理念对 Angular 2 的设计提供了灵感，Angular 2 就是以组件结构作为基础的。

由于上述背景，Angular 1.5 版本明确地推出了组件模式，并把它作为一个基于指令系统的 API。它通过制定规则、简化一些 API，最终允许应用开发者构建组件式的应用。

本章将实现这个应用层，它基于指令编译系统。组件的的开发内容包括组件本身的_定义 API_，同时还有一些控制器的生命周期方法，这些方法能让组件编写者可以对组件的各个生命周期绑定一些逻辑，包括：`$onInit`、`$postLink`、`$onChanges`和`$onDestroy`。